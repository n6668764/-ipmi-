import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import subprocess
import re
import configparser
import os
import logging
import threading
from datetime import datetime
from queue import Queue

# 配置日志系统
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(levelname)s - %(message)s',
    filename='ipmi_monitor.log',
    filemode='w'
)


class IPMIMonitorGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("IPMI硬件监控工具 v3.1")
        self.root.protocol("WM_DELETE_WINDOW", self.on_close)

        # 初始化参数
        self.data_queue = Queue()
        self.update_interval = 5000  # 5秒更新间隔
        self.running = True
        self.ipmitool_path = tk.StringVar()
        self.bmc_ip = tk.StringVar(value="192.168.8.181")
        self.bmc_user = tk.StringVar(value="albert")
        self.bmc_pass = tk.StringVar(value="admin")
        self.fan_percent_vars = {i: tk.IntVar(value=50) for i in range(1, 8)}

        # 初始化界面
        self.create_widgets()
        self.load_config()
        self.start_update_cycle()
        self.root.after(100, self.auto_apply_custom_mode)  # 添加自动应用功能

    def create_widgets(self):
        """创建界面组件"""
        # 顶部工具栏
        tool_frame = ttk.Frame(self.root)
        tool_frame.pack(fill=tk.X, padx=5, pady=5)

        # 工具路径组件
        ttk.Label(tool_frame, text="工具路径:").grid(row=0, column=0, padx=2)
        ttk.Entry(tool_frame, textvariable=self.ipmitool_path, width=30).grid(row=0, column=1, padx=2)
        ttk.Button(tool_frame, text="浏览", command=self.browse_ipmitool).grid(row=0, column=2, padx=2)

        # 连接参数组件
        ttk.Label(tool_frame, text="BMC IP:").grid(row=1, column=0, padx=2)
        ttk.Entry(tool_frame, textvariable=self.bmc_ip, width=15).grid(row=1, column=1, padx=2)
        ttk.Label(tool_frame, text="用户名:").grid(row=1, column=2, padx=2)
        ttk.Entry(tool_frame, textvariable=self.bmc_user, width=10).grid(row=1, column=3, padx=2)
        ttk.Label(tool_frame, text="密码:").grid(row=1, column=4, padx=2)
        ttk.Entry(tool_frame, textvariable=self.bmc_pass, show="*", width=10).grid(row=1, column=5, padx=2)
        ttk.Button(tool_frame, text="测试连接", command=self.test_connection).grid(row=1, column=6, padx=5)

        # 主内容区
        main_frame = ttk.Frame(self.root)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

        # 左侧传感器面板
        sensor_frame = ttk.LabelFrame(main_frame, text="传感器数据")
        sensor_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        # 温度监控分组
        temp_group = ttk.LabelFrame(sensor_frame, text="温度监控")
        temp_group.pack(fill=tk.X, padx=5, pady=2)

        self.temp_labels = {
            'CPU1_Temp': ttk.Label(temp_group, text="CPU1温度: --"),
            'CPU2_Temp': ttk.Label(temp_group, text="CPU2温度: --"),
            'PCH_Temp': ttk.Label(temp_group, text="主板温度: --")
        }
        for label in self.temp_labels.values():
            label.pack(anchor=tk.W, padx=5, pady=2)

        # 电源功率分组
        psu_group = ttk.LabelFrame(sensor_frame, text="电源监控")
        psu_group.pack(fill=tk.X, padx=5, pady=2)

        self.psu_labels = {
            'PSU1_POUT': ttk.Label(psu_group, text="电源1功率: --"),
            'PSU2_POUT': ttk.Label(psu_group, text="电源2功率: --")
        }
        for label in self.psu_labels.values():
            label.pack(anchor=tk.W, padx=5, pady=2)

        # 电压监控分组
        voltage_group = ttk.LabelFrame(sensor_frame, text="电压监控")
        voltage_group.pack(fill=tk.X, padx=5, pady=2)

        self.voltage_labels = {
            'P3V3': ttk.Label(voltage_group, text="3.3V电压: --"),
            'P5V': ttk.Label(voltage_group, text="5V电压: --"),
            'P12V': ttk.Label(voltage_group, text="12V电压: --"),
            'Vbat': ttk.Label(voltage_group, text="电池电压: --"),
            'CPU1_VCCIN': ttk.Label(voltage_group, text="CPU1输入电压: --"),
            'CPU2_VCCIN': ttk.Label(voltage_group, text="CPU2输入电压: --")
        }
        for label in self.voltage_labels.values():
            label.pack(anchor=tk.W, padx=5, pady=2)

        # 风扇转速面板
        fan_group = ttk.LabelFrame(sensor_frame, text="风扇转速 (RPM)")
        fan_group.pack(fill=tk.X, padx=5, pady=5)
        self.fan_labels = {}
        for i in range(1, 8):
            self.fan_labels[f'FAN{i}'] = ttk.Label(fan_group, text=f"风扇 {i}: --")
            self.fan_labels[f'FAN{i}'].grid(row=(i - 1) // 4, column=(i - 1) % 4, padx=5, pady=2, sticky=tk.W)

        # 右侧控制面板
        control_frame = ttk.LabelFrame(main_frame, text="风扇控制")
        control_frame.pack(side=tk.RIGHT, fill=tk.Y, padx=5, pady=5)

        # 模式选择
        self.mode_var = tk.StringVar()
        modes = ["静音模式", "性能模式", "自定义模式"]
        mode_combobox = ttk.Combobox(control_frame, textvariable=self.mode_var, values=modes, state="readonly")
        mode_combobox.pack(pady=5)
        mode_combobox.bind("<<ComboboxSelected>>", self.on_mode_selected)
        self.mode_var.set("静音模式")

        # 创建不同模式的Frame
        self.quiet_mode_frame = ttk.Frame(control_frame)
        self.performance_mode_frame = ttk.Frame(control_frame)
        self.custom_mode_frame = ttk.Frame(control_frame)

        # 静音模式内容
        ttk.Label(self.quiet_mode_frame, text="设置所有风扇为静音转速（30%）").pack(pady=5)
        ttk.Button(self.quiet_mode_frame, text="应用静音模式", command=lambda: self.apply_preset_mode(30)).pack(pady=5)

        # 性能模式内容
        ttk.Label(self.performance_mode_frame, text="设置所有风扇为高性能转速（80%）").pack(pady=5)
        ttk.Button(self.performance_mode_frame, text="应用性能模式", command=lambda: self.apply_preset_mode(80)).pack(
            pady=5)

        # 自定义模式内容
        for fan_id in range(1, 8):
            frame = ttk.Frame(self.custom_mode_frame)
            frame.pack(fill=tk.X, padx=5, pady=2)
            ttk.Label(frame, text=f"风扇 {fan_id}:").pack(side=tk.LEFT)
            spinbox = ttk.Spinbox(frame, from_=0, to=100, textvariable=self.fan_percent_vars[fan_id], width=5)
            spinbox.pack(side=tk.LEFT, padx=5)
            ttk.Button(frame, text="设置", command=lambda fid=fan_id: self.set_single_fan(fid)).pack(side=tk.LEFT)

        # 初始显示静音模式
        self.quiet_mode_frame.pack(fill=tk.X, padx=5, pady=5)

        # 状态栏
        self.status_var = tk.StringVar(value="就绪")
        status_bar = ttk.Label(self.root, textvariable=self.status_var, relief=tk.SUNKEN)
        status_bar.pack(side=tk.BOTTOM, fill=tk.X)

    def on_mode_selected(self, event=None):
        """模式选择事件处理"""
        selected_mode = self.mode_var.get()
        self.quiet_mode_frame.pack_forget()
        self.performance_mode_frame.pack_forget()
        self.custom_mode_frame.pack_forget()

        if selected_mode == "静音模式":
            self.quiet_mode_frame.pack(fill=tk.X, padx=5, pady=5)
        elif selected_mode == "性能模式":
            self.performance_mode_frame.pack(fill=tk.X, padx=5, pady=5)
        elif selected_mode == "自定义模式":
            self.custom_mode_frame.pack(fill=tk.X, padx=5, pady=5)

    def percent_to_hex(self, percent):
        """百分比转换为十六进制"""
        if percent < 0 or percent > 100:
            raise ValueError("百分比必须在0到100之间")
        return f"0x{int(percent):02x}"

    def apply_preset_mode(self, percent):
        """应用预设模式"""

        def apply_task():
            try:
                self.enter_manual_mode()
                for fan_id in range(1, 8):
                    hex_speed = self.percent_to_hex(percent)
                    self.run_ipmitool(['raw', '0x2e', '0x30', '00', f'0{fan_id}', hex_speed])
                self.status_var.set(f"预设模式应用成功: {percent}%")
                messagebox.showinfo("成功", f"所有风扇已设置为{percent}%")
            except Exception as e:
                messagebox.showerror("错误", f"应用预设模式失败: {str(e)}")

        threading.Thread(target=apply_task, daemon=True).start()

    def set_single_fan(self, fan_id):
        """设置单个风扇转速"""
        percent = self.fan_percent_vars[fan_id].get()
        try:
            self.enter_manual_mode()
            hex_speed = self.percent_to_hex(percent)
            self.run_ipmitool(['raw', '0x2e', '0x30', '00', f'0{fan_id}', hex_speed])
            self.status_var.set(f"风扇{fan_id}已设置为{percent}%")
            messagebox.showinfo("成功", f"风扇{fan_id}转速已设置为{percent}%")
        except Exception as e:
            messagebox.showerror("错误", f"设置失败: {str(e)}")

    def start_update_cycle(self):
        """启动数据更新线程"""
        self.update_thread = threading.Thread(target=self.update_worker, daemon=True)
        self.update_thread.start()
        self.root.after(100, self.process_queue)

    def update_worker(self):
        """后台数据获取线程"""
        while self.running:
            try:
                output = self.run_ipmitool(['sensor', 'list'])
                sensors = self.parse_sensor_data(output)
                self.data_queue.put(sensors)
                self.status_var.set(f"最后更新: {datetime.now().strftime('%H:%M:%S')}")
            except Exception as e:
                self.data_queue.put(e)
            finally:
                threading.Event().wait(self.update_interval / 1000)

    def process_queue(self):
        """处理数据队列（主线程）"""
        try:
            while not self.data_queue.empty():
                item = self.data_queue.get_nowait()
                if isinstance(item, Exception):
                    self.status_var.set(f"错误: {str(item)}")
                    logging.error(str(item))
                else:
                    self.update_ui(item)
        finally:
            if self.running:
                self.root.after(100, self.process_queue)

    def update_ui(self, sensors):
        """更新界面数据"""
        # 更新温度
        for name, label in self.temp_labels.items():
            value = sensors.get(name, 'N/A')
            label.config(
                text=f"{label.cget('text').split(':')[0]}: {value}℃" if value != 'N/A' else f"{label.cget('text').split(':')[0]}: --")

        # 更新电源功率
        for name, label in self.psu_labels.items():
            value = sensors.get(name, 'N/A')
            label.config(
                text=f"{label.cget('text').split(':')[0]}: {value}W" if value != 'N/A' else f"{label.cget('text').split(':')[0]}: --")

        # 更新电压
        for name, label in self.voltage_labels.items():
            value = sensors.get(name, 'N/A')
            formatted_value = f"{float(value):.3f} V" if value != 'N/A' else '--'
            label.config(text=f"{label.cget('text').split(':')[0]}: {formatted_value}")

        # 更新风扇转速
        for i in range(1, 8):
            fan_key = f'FAN{i}_R_Speed'
            value = sensors.get(fan_key, 'N/A')
            self.fan_labels[f'FAN{i}'].config(text=f"风扇 {i}: {value} RPM" if value != 'N/A' else f"风扇 {i}: --")

    def browse_ipmitool(self):
        """选择ipmitool路径"""
        path = filedialog.askopenfilename(
            title="选择ipmitool可执行文件",
            filetypes=[("可执行文件", "*.exe"), ("所有文件", "*.*")]
        )
        if path:
            self.ipmitool_path.set(path)
            self.save_config()

    def load_config(self):
        """加载配置文件"""
        config = configparser.ConfigParser()
        if os.path.exists('config.ini'):
            try:
                config.read('config.ini')
                self.ipmitool_path.set(config.get('DEFAULT', 'ipmitool_path', fallback=""))
                self.bmc_ip.set(config.get('DEFAULT', 'ip', fallback=self.bmc_ip.get()))
                self.bmc_user.set(config.get('DEFAULT', 'user', fallback=self.bmc_user.get()))
                self.bmc_pass.set(config.get('DEFAULT', 'password', fallback=self.bmc_pass.get()))

                # 模式有效性检查
                saved_mode = config.get('DEFAULT', 'mode', fallback="静音模式")
                if saved_mode not in ["静音模式", "性能模式", "自定义模式"]:
                    saved_mode = "静音模式"
                self.mode_var.set(saved_mode)

                for fan_id in range(1, 8):
                    self.fan_percent_vars[fan_id].set(
                        config.getint('DEFAULT', f'fan_{fan_id}_percent', fallback=50))
            except Exception as e:
                logging.error(f"配置加载失败: {str(e)}")

    def save_config(self):
        """保存配置文件"""
        config = configparser.ConfigParser()
        config['DEFAULT'] = {
            'ipmitool_path': self.ipmitool_path.get(),
            'ip': self.bmc_ip.get(),
            'user': self.bmc_user.get(),
            'password': self.bmc_pass.get(),
            'mode': self.mode_var.get()
        }
        for fan_id in range(1, 8):
            config['DEFAULT'][f'fan_{fan_id}_percent'] = str(self.fan_percent_vars[fan_id].get())
        with open('config.ini', 'w') as f:
            config.write(f)

    def on_close(self):
        """窗口关闭事件"""
        self.running = False
        if hasattr(self, 'update_thread') and self.update_thread.is_alive():
            self.update_thread.join(timeout=1)
        self.save_config()
        self.root.destroy()

    def test_connection(self):
        """测试BMC连接"""
        try:
            output = self.run_ipmitool(['sensor', 'list'])
            messagebox.showinfo("连接成功", "BMC连接验证通过！")
        except Exception as e:
            messagebox.showerror("连接失败", f"错误信息:\n{str(e)}")

    def run_ipmitool(self, command):
        """执行IPMI命令"""
        if not os.path.exists(self.ipmitool_path.get()):
            raise FileNotFoundError(f"找不到ipmitool: {self.ipmitool_path.get()}")

        cmd = [
                  self.ipmitool_path.get(),
                  '-I', 'lanplus',
                  '-H', self.bmc_ip.get(),
                  '-U', self.bmc_user.get(),
                  '-P', self.bmc_pass.get()
              ] + command

        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            check=True,
            timeout=15
        )
        return result.stdout

    def parse_sensor_data(self, output):
        """解析传感器数据"""
        sensors = {}
        for line in output.splitlines():
            if not line.strip() or '|' not in line:
                continue
            parts = [p.strip() for p in line.split('|')]
            if len(parts) >= 4:
                sensor_name = parts[0].replace(" ", "_")
                sensor_value = parts[1]

                # 过滤无效值
                if sensor_value.lower() in ['na', 'disabled', '']:
                    continue

                # 数值格式化处理
                try:
                    float(sensor_value)  # 验证是否为数值
                    sensors[sensor_name] = sensor_value
                except ValueError:
                    pass
        return sensors

    def auto_apply_custom_mode(self):
        """开机自动应用自定义模式设置"""
        if self.mode_var.get() == "自定义模式":
            self.status_var.set("正在自动应用自定义模式设置...")
            self.apply_custom_settings()

    def apply_custom_settings(self):
        """应用保存的自定义设置"""

        def apply_task():
            try:
                self.enter_manual_mode()
                success_count = 0
                for fan_id in range(1, 8):
                    percent = self.fan_percent_vars[fan_id].get()
                    try:
                        hex_speed = self.percent_to_hex(percent)
                        self.run_ipmitool(['raw', '0x2e', '0x30', '00', f'0{fan_id}', hex_speed])
                        success_count += 1
                        logging.info(f"风扇{fan_id}设置成功: {percent}%")
                    except Exception as e:
                        logging.error(f"风扇{fan_id}设置失败: {str(e)}")

                self.status_var.set(f"自定义模式设置应用完成，成功设置{success_count}/7个风扇")
                if success_count < 7:
                    messagebox.showwarning("部分成功",
                                           f"成功设置{success_count}个风扇，请检查未设置成功的风扇连接")

            except Exception as e:
                logging.error(f"自动应用设置失败: {str(e)}")
                messagebox.showerror("自动应用失败",
                                     f"无法自动应用自定义设置:\n{str(e)}")

        # 在独立线程中执行设置操作
        threading.Thread(target=apply_task, daemon=True).start()

    def enter_manual_mode(self):
        """进入手动控制模式"""
        try:
            self.run_ipmitool(['raw', '0x30', '0x30', '0x01', '0x00'])
        except Exception as e:
            logging.warning(f"进入手动模式失败: {str(e)}")


if __name__ == "__main__":
    root = tk.Tk()
    try:
        app = IPMIMonitorGUI(root)
        root.mainloop()
    except Exception as e:
        logging.critical(f"程序崩溃: {str(e)}")
        messagebox.showerror("致命错误", f"程序异常终止:\n{str(e)}")
